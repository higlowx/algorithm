package com.higlowx.algorithm.jzoffer;

/**
 * 只出现一次的数字
 *
 * 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。
 *
 * 示例 :
 * 输入: [1,2,1,3,2,5]
 * 输出: [3,5]
 *
 * 注意：
 * 结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。
 * 你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？
 *
 * leetcode：https://leetcode-cn.com/problems/single-number-iii
 * nowcoder：https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811
 *
 * 部分概念请参考{@link JzOffer11}
 *
 * @author Dylan.Li
 * @date 2020/12/25
 */

public class JzOffer40 {

    public int[] singleNumber(int[] nums) {
        //参照 找出数组中唯一的出现一次的数 一题
        //如果在该题中使用全部按位异或，得到的结果是两个出现一次的数的异或结果
        //* 分析其结果：两数不同，则异或结果的二进制位里，所有1的位置即两数二进制中不同的位，一个是0，则另一个一定是1
        //利用上述分析结果继续推，如果我们可以把数组[1,1,3,4,4,5] 一分为二，把3和5分别放到不同的子数组中，然后将两个数组分别按位异或，如果这两个数组是[3,a,a][5,b,b]这种，则分别异或就可得到3和5了
        //要实现上述效果，有一个大前提，即每个数组不可出现[3,a,a,b]这种，其内部除了目标数之外，其余数字都必须是成对存在的，怎么实现这种效果呢？
        //利用 * 行结论，如果两数不同，其二进制一定不同；异或结果最低位的1出现的位置上，原数组所有数的那一位是[1|0]为依据，将数组一分为二，为1的分为一组，为0的分为另一组，即可完成分组了
        int gen = 0;
        for(int num : nums){
            gen = gen ^ num;
        }
        //扩展1：
        //怎么把int类型的数，提取出最右侧的1来
        //公式: N & ( (~N) + 1)
        //int           N = 0...0 0 1 0 1 0 1 0 0 0
        //取反：        ~N = 1...1 1 0 1 0 1 0 1 1 1
        //取反后+1  ~N + 1 = 1...1 1 0 1 0 1 1 0 0 0

        //result = N & ( (~N) + 1) =
        //  0...0 0 1 0 1 0 1 0 0 0 &
        //  1...1 1 0 1 0 1 1 0 0 0
        //= 0...0 0 0 0 0 0 1 0 0 0
        //result即 提取出 原数N 最右侧的1后，其他位变为0 的结果

        //以上步骤中 (~N)+1 与 负数的补码计算 几乎一样（唯一不同是负数的符号位为1，且不参与补码计算过程）

        //扩展2：
        //正数的补码 是 其本身
        //负数的补码 是 符号位不变，其他位 取反后+1

        //扩展3：
        //java中所有的整数均以 二进制补码形式 存储
        //即 1 存储为 0..0001，-1 存储为 1..1111
        //1 & -1 = 0..0001

        //提取最低位1
        int mask = gen & (-gen);

        //扩展4：
        //任何整数 & 0001 == 1，表明该数最低位必定是1；
        //任何整数 & 0001 == 0，表明该数最低位必定是0；
        // 1 & 1 = 1, 0 & 1 = 0, 0 & 0 = 0

        //分组并进行异或计算
        int result0 = 0;
        for(int num : nums){
            if((num & mask) == 0){
                result0 ^= num;
            }
        }
        //很巧妙，按位异或运算
        //a ^ b = c 必有 b ^ c = a
        return new int[]{result0,gen ^ result0};
    }
}
