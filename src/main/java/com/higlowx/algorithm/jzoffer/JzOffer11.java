package com.higlowx.algorithm.jzoffer;

/**
 * 输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。
 *
 * @author Dylan.Lee
 * @date 2020/11/19
 * @since
 */

public class JzOffer11 {

    /**
     * 知识铺垫：
     * 1、右移和无符号右移：
     * 正数的无符号右移和有符号右移，高位都是补0，所以最终效果一样，但是负数的无符号右移>>>高位补0，有符号右移>>高位补1
     * <p>
     * 2、题目要求，负数用补码表示，这里复习一下补码的计算方式：
     * a、正整数的补码是其二进制表示，与原码相同；
     * b、负整数的补码，将其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1
     * 比如，以-1为例：
     * 计算正数1的二进制为0000 0001，并将高位（符号位）由0变为1，得到1000 0001
     * -> 将1000 0001（-1的二进制原码）取反（除了符号位以外取反哦）得到1111 1110
     * -> 将1111 1110（-1的二进制原码的反码）+1，得到1111 1111，即最终的补码
     * <p>
     * 3、java中所有数字都是默认用补码表示的，所以这里不用处理负数的逻辑
     */

    /**
     * 假如n=3
     * n的二进制为 0000 0011
     * 这里要应用位运算中的一种：按位异或 ^，即 1^1=0,1^0=1,0^0=0
     * 那么如何操作呢
     * 我们假设 0000 0011与其自身做异或，即 0000 0011 ^ 0000 0011 = 0000 0000，结果转换为10进制，也就是0
     * 我们发现异或的目标值中所有的1都变为了0,
     * 如果我们将0000 0011与0000 0001（1的二进制）做按位异或，第一次得到的结果为0000 0010，此时我们消除掉了0000 0011中的最低位的1,
     * 再将第一次得到的0000 0010，无符号右移一位，即 0000 0010 >>> 1 = 0000 0001
     * 我们将得到的0000 0001再跟0000 0001（还是1的二进制）做异或运算，最终会得到0000 0000，即十进制0，
     * 到此为止，我们一共计算了两次，最初始的0000 0011中的1已经全部被消除，按照计算一次消除一个1的逻辑，最终就得出，0000 0011一共有2个1
     *
     * @see 该方法存在缺陷
     * @see 以上逻辑具体实现为方法0,实际得到的结果证明,该方法仅仅能正确计算出
     * @see 像00001111这样的从最低位向高位延展,所有的1都是相邻的,中间没有被0分隔开且最低位一定是0这样的数
     * @see 具体实际计算结果可以参考main方法中的前三行输出,一二行的输出一直且正确,第三行不一致
     */
    public int numberOfOne0(int n) {
        int count = 0;
        while (n != 0) {
            n ^= 1;
            count++;
            n >>= 1;
        }
        return count;
    }

    /**
     * 位运算 n & (n-1)
     * <p>
     * 该方法精华在于，n-1体现在二进制中，相对于n本身，实际上等效于将n的二进制中最右边的第一个1变成0，并且最右边的第一个1右边的0全部变为1
     * 我们都知道，0 & 1 = 0，也就是说最右边的第一个1右边的0全部变为1后不影响最终的计算结果，而且计算结果 = 将n的二进制中最右边的第一个1变成0
     */
    public int numberOfOne1(int n) {
        int count = 0;
        while (n != 0) {
            n &= (n - 1);
            count++;
        }
        return count;
    }

    public static void main(String[] args) {

        System.out.println("0000 0100中1的个数，Integer.bitCount：" + Integer.bitCount(8));
        System.out.println("0000 0100中1的个数，numberOfOne1：" + new JzOffer11().numberOfOne1(8));
        System.out.println("0000 0100中1的个数，numberOfOne0：" + new JzOffer11().numberOfOne0(8));

        System.out.println("0111 1111中1的个数，Integer.bitCount：" + Integer.bitCount(64 + 32 + 16 + 8 + 4 + 2 + 1));
        System.out.println("0111 1111中1的个数，numberOfOne1：" + new JzOffer11().numberOfOne1(64 + 32 + 16 + 8 + 4 + 2 + 1));
        System.out.println("0111 1111中1的个数，numberOfOne0：" + new JzOffer11().numberOfOne0(64 + 32 + 16 + 8 + 4 + 2 + 1));

    }
}
